---
title: Working With GraphQL
index: 2
description: An overview of the store-based API provided by Houdini and how it relates to documents found inside of svelte files.
---

<script>
    import { Highlight, HighlightAuto } from 'svelte-highlight'
    import graphqlLangDef from '~/lib/graphql-language'
    import { Transformation } from '~/components'

    const graphql = { name: 'graphql', register: graphqlLangDef }

    const storeSource = `query ViewerProfile {
        viewer {
            firstName
        }
    }`

    const storeTypeDef = `type ViewerProfileStore = {
    subscribe: Readable<ViewerProfile>
    fetch(...): Promise<ViewerProfile>
}`
</script>

# Working with GraphQL

There are two different ways you can define graphql documents in a Houdini application. You can either take advantage of the preprocessor to define your
documents inside of `.svelte` files or you can define them in external graphql files and interact the document's dedicated store. While the two approaches are totally equivalent, they have
different strengths and weaknesses so you'll often find yourself mixing and matching the techniques (sometime in the same component!).

Before we get to the actual differences we should first go over the core abstraction powering Houdini's data fetching: document stores.

## Document Stores

When you run the `generate` command, Houdini creates a dedicated store for every document it runs into (either inside of a `.svelte` or graphql file).

For example, a graphql document containing a query will have a corresponding store generated that is not only responsible for
querying your API but also subscribing to changes in Houdini's cache so everything is kept in sync when mutations and subscriptions fire.

<Transformation>
    <Highlight language={graphql} code={storeSource} slot="from"/>
    <HighlightAuto code={storeTypeDef} slot="to" />
</Transformation>

A component that wants to use a query defined in an external file would look like the following. Note that these stores can be imported and used directly
anywhere in your project (components, endpoints, hooks, etc.).

```svelte
<script context="module">
    import ViewerProfileStore from '$houdini/stores/ViewerProfile'
    import { browser } from '$app/env'

    export async load(event) {
        // make sure the store has the latest data
        await ViewerProfileStore.prefetch({ event })

        // have to return _something_ to make sveltekit happy
        return {}
    }
</script>

{$ViewerProfileStore.data.viewerProfile.firstName}

<!-- make sure that the latest value is always fetched -->
$: browser && ViewerProfileStore.fetch()

```

And using a mutation store looks something like

```svelte
<script>
    import AddUser from '$houdini/stores/AddUser'
    import { getHoudiniContext } from '$houdini/runtime'

    // the context must be pulled out at the root of your component
    // so your HoudiniClient's fetch function has everything it needs
    const context = getHoudiniContext()

    // a function to invoke the mutation
    const addUser = () => AddUser.mutate({
        context,
        variables: { firstName: "Houdini" }
    })
</script>

<button on:click={addUser} />
```

While the stores are incredibly flexible, we're already starting to see the biggest downside:
there is a lot of boilerplate required to connect your component and store.
Every time you invoke `.mutate` you have to pass in the component context. For a query store, you
must remember to use `store.prefetch` in `load` and `store.fetch` in the component. You also have to thread
the query variables from your `load` function into the call to `store.fetch`. If this seems like a lot
to remember, don't worry - that's where the preprocessor comes in.

## Inline Documents

Houdini's preprocessor is a powerful tool that enables a more declarative API and hides a lot of the
complexity we saw in the previous section. To use the preprocessor, you must define your queries directly inside of your
svelte components. For example, a route that depends on the result of a query looks something like this:

```svelte
<script>
	import { graphql, query } from '$houdini'

	const { data } = query(graphql`
		query ViewerProfile {
			viewer {
				firstName
			}
		}
	`)
</script>

{$ViewerProfileStore.data.viewerProfile.firstName}
```

Notice that you didn't have to define a loader for your route? That the magic of the preprocessor.
It generates all of that for you!

Mutations also have a simpler API with the preprocessor. Notice how there's no more need to pass `context`:

```svelte
<script>
    import AddUser from '$houdini/stores/AddUser'
    import { getHoudiniContext } from '$houdini/runtime'


    // a function to invoke the mutation
    const addUser = mutation(graphql`
        mutation AddUser($firstName: String!) {
            addUser(firstName: $firstName) {
                newUser {
                    id
                }
            }
        }
    `)
</script>

<button on:click={() => addUser({ firstName: "Houdini" })} />
```

## Inline Documents vs Stores? Why not both?

So does that mean you should just always use the preprocessor and ignore the document stores? Well.... no. Not always.

What you gain in simplicity with the preprocessor, you lose in flexibility.
The preprocessor can only run on `.svelte` files so if you want to do things inside of an endpoint or
any random file, you'll need to use the store api. If you want to send custom headers for just a single
request, you'll need the store api. You should think of a document store's api as a lower level mechanism for
interacting with your graphql documents when you need to do something special with a query but you will be responsible
for the details.
