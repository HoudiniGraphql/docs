---
title: Query
index: 1
description: Queries in Houdini
---

<script>
    import { HeaderWithMode } from '~/components'
    import { Highlight, HighlightAuto } from 'svelte-highlight'
    import graphqlLangDef from '~/lib/graphql-language'
    import { Transformation } from '~/components'

    const graphql = { name: 'graphql', register: graphqlLangDef }
     let mode

	 const forwardPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(first: 10) @paginate( name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const forwardPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    houdiniContext: HoudiniContext,
    pageCount?: number,
    after?: string | number
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const backwardsPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(last: 10) @paginate(name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const backwardsPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadPreviousPage(
    houdiniContext: HoudiniContext,
    pageCount?: number,
    before?: string | number
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const offsetPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(limit: 10) @paginate(name: "My_Friends") {
      id
    }
  }
}
`
	const offsetPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    houdiniContext: HoudiniContext,
    limit?: number,
    offset?: number
  ): Promise<void>,
}
`
</script>

<HeaderWithMode title="Query" bind:mode  />

Load data from the server and subscribe to any changes of fields we detect from mutations, subscriptions, and other queries.

```svelte
<script context="module">
    import ViewerProfileStore from '$houdini/stores/ViewerProfile'

    export async load(event) {
        // make sure the store has the latest data
        await ViewerProfileStore.prefetch({ event })

        // have to return _something_ to make SvelteKit happy
        return {}
    }
</script>

{$ViewerProfileStore.data.viewerProfile.firstName}

<!-- retrieve the latest value from the cache -->
$: browser && ViewerProfileStore.fetch()
```

### Store Value

A query store holds onto an object containing a variety of metadata
about the last query that was sent:

- `data`: holds the result of the query
- `errors`: a list of objects with a `message` field
- `isFetching`: a boolean that tracks the fetchingState (always false after a request)
- `partial`: a boolean indicating of the query has partial results. For more information see the [caching guide](/guides/caching-data#partial-data)
- `source`: one of `"network"` or `"cache"`. Indicates wether the result was read from the cache or the network
- `variables`: the variables used for the request

## Fetching Data

A query store's primary goal is to fetch data from the server. This is achieved in two parts:

1. Prefetching the data and loading it into the cache as early as possible
1. Fetching the data from the cache and rendering the component

### Prefetching

A lot of the times you will try to load data into the cache before the user needs it on their screen. For example,
in a SvelteKit application, you will likely make heavy use of the `sveltekit:prefetch` attribute to cause data to
load before your user clicks on a link. In SvelteKit, this happens in a function called `load` which looks something like:

```javascript
import MyQueryStore from '$houdini/stores/MyQuery'

export async function load(event) {
	await MyQueryStore.prefetch({ event })

	return {}
}
```

If we're not careful, the above code will cause every route transition to
block while the store waits for the server. While this sounds great
for server-side rendered views, this is usually not what we want for
client-side transitions. In order to accommodate this, awaiting
`fetch` does not actually wait for the promise to resolve when
the request happens on the browser. This means that if you want to
do something with the response, you have to pass `blocking: true`
which will make the `await` behave like normal:

```javascript
export async function load(event) {
	// blocking:true makes this await "real"
	const { data } = await MyStore.prefetch({ event, blocking: true })

	// check the response of the query and redirect when appropriate
	if (!data.fieldName) {
		return {
			redirect: '/not-field-name'
		}
	}

	return {}
}
```

### Fetching Data on the Browser

Once the view has been rendered on the server, we need our client to start listening for updates
in the cache and propagating those changes to our store. When our variables change, we need to
make sure that data is present and potentially subscribe to new changes. All of this is done with
the `fetch` method. The simplest situation looks something like:

```svelte
<script context="module">
  import { browser } from '$app/env'
  import MyQueryStore from '$houdini/stores/MyQuery'

  export async function load(event) {
    await MyQueryStore.prefetch({ event })

    return {}
  }
</script>

<script>
  $: browser && MyQueryStore.fetch()
</script>

{$MyQueryStore.data.value}
```

Things are slightly more complicated when you want to pass variables to your query:

```svelte
<script context="module">
  import { browser } from '$app/env'
  import MyQueryStore from '$houdini/stores/MyQuery'

  export async function load(event) {
    const variables = { ... }

    await MyQueryStore.prefetch({ event })

    return {
      props: {
        variables
      }
    }
  }
</script>

<script>
  export let variables

  $: browser && MyQueryStore.fetch({ variables })
</script>


{$MyQueryStore.data.value}
```

We know this API isn't ideal but we couldn't come up with anything better after many days of exploration. If you
have any ideas, please open a discussion and let's chat!

### Fetch Return Value

`fetch` returns a Promise that usually resolves with an object described in [Store Value](#store-value).
Keep in mind that when the `blocking` parameter is not set to true, `fetch`'s promise does not
always resolve with something. When it is called on the client-side, the function does not actually wait
for the request from the server in order to avoid unintended pauses when navigating between routes.

## Paginated Queries

If the query contains the pagination directive then the generated store will have extra fields/methods
according to the pagination strategy and direction. For more information about pagination in general, check
out [this guide](/guides/pagination).

### Forward cursor pagination

If the decorated field implements cursor-based pagination and provides a `first` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={forwardPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={forwardPaginationStoreAfter} />
</Transformation>

### Backwards cursor pagination

If the decorated field implements cursor-based pagination and provides a `last` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={backwardsPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={backwardsPaginationStoreAfter} />
</Transformation>

### Offset/limit Pagination

If the decorated field implements offset/limit pagination and provides a `limit` argument, the query store will be generated with an extra methods that lets it load more pages after the one the current one:

<Transformation>
	<Highlight slot="from" code={offsetPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={offsetPaginationStoreAfter} />
</Transformation>
