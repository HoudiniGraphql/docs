---
title: Query
index: 1
description: Queries in Houdini
---

<script>
    import HeaderWithMode from './_HeaderWithMode.svelte'
    import { Highlight, HighlightAuto } from 'svelte-highlight'
    import graphqlLangDef from '~/lib/graphql-language'
    import { Transformation } from '~/components'

    const graphql = { name: 'graphql', register: graphqlLangDef }
     let mode

	 const forwardPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(first: 10) @paginate( name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const forwardPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    houdiniContext: HoudiniContext,
    pageCount?: number,
    after?: string | number
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const backwardsPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(last: 10) @paginate(name: "My_Friends") {
      edges {
        node {
          id
        }
      }
  }
}
`
	const backwardsPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadPreviousPage(
    houdiniContext: HoudiniContext,
    pageCount?: number,
    before?: string | number
  ): Promise<void>,

  pageInfo: Readable<PageInfo>
}
`
	 const offsetPaginationStoreBefore = `
query MyFriends {
  viewer {
    friends(limit: 10) @paginate(name: "My_Friends") {
      id
    }
  }
}
`
	const offsetPaginationStoreAfter = `
type MyFriendsStore = QueryStore & {
  loadNextPage(
    houdiniContext: HoudiniContext,
    limit?: number,
    offset?: number
  ): Promise<void>,
}
`
</script>

<HeaderWithMode title="Query" bind:mode  />

Load data from the server and subscribe to any changes of fields we detect from mutations, subscriptions, and other queries.

{#if mode === 'inline'}

```svelte
<script>
	import { query, graphql } from '$houdini'
	const { data, refetch, loading, error } = query(graphql`
		query MyQuery {
			myField
		}
	`)
</script>
```

### Inputs

1. A string tagged with `graphql` containing a single document with one named query

### Return Values

`query` returns a single object with the following keys:

- `data` is a store containing the result of the query. It's value will update as mutations, subscriptions, and other queries provide more recent information.
- `refetch` is a function that will refetch the query with a new set of arguments.
- `loading` is a store containing the loading state (`true` or `false`) for a query found outside of a route component (ie, not defined in `src/routes`)
- `errors` is a store containing any error values that occur for a query found outside of a route component (ie, not defined in `src/routes`)
- `partial` is a store containing a boolean that indicates if the result has a partial match

{:else}

```svelte
<script context="module">
    import ViewerProfileStore from '$houdini/stores/ViewerProfile'

    export async load(event) {
        // make sure the store has the latest data
        await ViewerProfileStore.fetch({ event })

        // have to return _something_ to make SvelteKit happy
        return {}
    }
</script>

{$ViewerProfileStore.data.viewerProfile.firstName}
```

### Store Value

A query store holds onto an object containing a variety of metadata
about the last query that was sent:

- `data`: holds the result of the query
- `errors`: a list of objects with a `message` field
- `isFetching`: a boolean that tracks the fetchingState (always false after a request)
- `partial`: a boolean indicating of the query has partial results. For more information see the [caching guide](/guides/caching-data#partial-data)
- `source`: one of `"network"` or `"cache"`. Indicates wether the result was read from the cache or the network
- `variables`: the variables used for the request

{/if}

## Fetching Data

{#if mode === 'inline'}

### Query Variables

At the moment, query variables are declared as a function in the module context of your component.
This function must be named after your query and in a sapper application, it takes the same arguments
that are passed to the `preload` function described in the [Sapper](https://sapper.svelte.dev/docs#Pages)
documentation. In a SvelteKit project, this function takes the same arguments passed to the `load` function
described in the [SvelteKit](https://kit.svelte.dev/docs#Loading) docs. Regardless of the framework, you can return
the value from `this.error` and `this.redirect` in order to change the behavior of the response. Here is a
modified example [from the source repository](./https://github.com/HoudiniGraphql/houdini/tree/main/example):

```svelte
<script context="module" lang="ts">
	// This is the function for the AllItems query.
	// Query variable functions must be named <QueryName>Variables.
	export function AllItemsVariables(page): AllItems$input {
		// make sure we recognize the value
		if (!['active', 'completed'].includes(page.params.filter)) {
			return this.error(400, 'invalid filter')
		}

		return {
			completed: page.params.filter === 'completed'
		}
	}
</script>

<!-- src/routes/[filter].svelte -->
<script lang="ts">
	import { query, graphql, AllItems } from '$houdini'

	// load the items
	const { data } = query<AllItems>(graphql`
		query AllItems($completed: Boolean) {
			items(completed: $completed) {
				id
				text
			}
		}
	`)
</script>

{#each $data.items as item}
	<div>{item.text}</div>
{/each}
```

### Loading State

The methods used for tracking the loading state of your queries changes depending
on the context of your component. For queries that live in routes (ie, in
`/src/routes/...`), the actual query happens in a `load` which means the best way to track
if your query is loading is to use the
[navigating store](https://kit.svelte.dev/docs#modules-$app-stores) exported from `$app/stores`:

```svelte
<!-- src/routes/index.svelte -->
<script>
    import { query } from '$houdini'
    import { navigating } from '$app/stores'

    const { data } = query(...)
</script>

{#if $navigating}
	loading...
{:else}
	data is loaded!
{/if}
```

However, since queries inside of non-route components (ie, ones that are not defined in `/src/routes/...`)
do not get hoisted to a `load` function, the recommended practice to is use the store returned from
the result of query:

```svelte
<!-- src/components/MyComponent.svelte -->
<script>
    import { query } from '$houdini'

    const { data, loading } = query(...)
</script>

{#if $loading}
	loading...
{:else}
	data is loaded!
{/if}
```

### Refetching Data

Refetching data is done with the `refetch` function provided from the result of a query:

```svelte
<script lang="ts">
	import { query, graphql, AllItems } from '$houdini'

	// load the items
	const { refetch } = query<AllItems>(graphql`
		query AllItems($completed: Boolean) {
			items(completed: $completed) {
				id
				text
			}
		}
	`)

	let completed = true

	$: refetch({ completed })
</script>

<input type="checkbox" bind:checked={completed} />
```

{:else}

A query store's primary goal is to fetch data from the server. This is achieved using the `fetch` method on the store.

### Fetching in `load`

When used inside of a route's `load` function, `fetch` must be passed
the [LoadEvent](https://kit.svelte.dev/docs/types#sveltejs-kit-loadevent) as the `event` key.

```javascript
export async function load(event) {
	await MyStore.fetch({ event })

	return {}
}
```

In SvelteKit, the above code will cause every route transition to
block while the store waits for the server. While this sounds great
for server-side rendered views, this is usually not what we want for
client-side transitions. In order to accommodate this, awaiting
`fetch` does not actually wait for the promise to resolve when
the request happens on the browser. This means that if you want to
do something with the response, you have to pass `blocking: true`
which will make the `await` behave like normal:

```javascript
export async function load(event) {
	// blocking:true makes this await "real"
	const { data } = await MyStore.fetch({ event, blocking: true })

	// check the response of the query and redirect when appropriate
	if (!data.fieldName) {
		return {
			redirect: '/not-field-name'
		}
	}

	return {}
}
```

### Fetching on the client

Fetching on the client, say in an handler like `on:click`, requires a slightly
different set of values than the server-side equivalent. Most importantly, `event` is not required:

```svelte
<script>
    import MyQueryStore from '$houdini/stores/MyQuery'
</script>

$: browser && MyQueryStore.fetch();
```

However, if you require `session` or `page` in your in
your client's fetch function, you must retrieve that information
from your component's context and pass that to the call to `fetch`:

```svelte
<script>
    import MyQueryStore from '$houdini/stores/MyQuery'
    import { getHoudiniContext } from '$houdini/runtime'

    const houdiniContext = getHoudiniContext()
</script>

$: browser && MyQueryStore.fetch({ context: houdiniContext });
```

### Specifying Variables

`fetch` can take an optional `variables` key in its arguments:

```javascript
MyStore.fetch({ variables: { some: 'value' } })
```

You only need to specify the variables that you want changed. The store will reuse any variables it's been given in past calls to
`fetch`.

### Return Value

`fetch` returns a Promise that usually resolves with an object described in [Store Value](#store-value).
Keep in mind that when the `blocking` parameter is not set to true, `fetch`'s promise does not
always resolve with something. When it is called on the client-side, the function does not actually wait
for the request from the server in order to avoid unintended pauses when navigating between routes.

{/if}

## Paginated Queries

{#if mode === 'inline'}

Paginated queries must use the `paginatedQuery` function exported from your runtime and contain the `@paginate` directive on the appropriate field. For more information Houdini's support for pagination, please visit the [Pagination guide](/guides/pagination).

```svelte
<script>
	import { paginatedQuery, graphql } from '$houdini'
	const { data, loadNextPage } = paginatedQuery(graphql`
		query UserList {
			friends(last: 10) @paginate {
				edges {
					node {
						id
					}
				}
			}
		}
	`)
</script>
```

### Return Values

`paginatedQuery` returns the same values as `query` with a few additions:

- `loadNextPage` is an async function that loads the next page. It takes one optional argument: the page size to load for the next request.
- `loadPreviousPage` is an async function that loads the previous page. It takes one optional argument: the page size to load for the next request.
- `loading` is a store containing a boolean value that tracks the loading state of the pagination requests
- `pageInfo` is a store that contains the page info (`hasPreviousPage`, `hasNextPage`, etc.) Only valid for cursor-based pagination.
- `partial` is a store containing a boolean that indicates if the result has a partial match

{:else}

If the query contains the pagination directive then the generated store will have extra fields/methods
according to the pagination strategy and direction. For more information about pagination in general, check
out [this guide](/guides/pagination).

### Forward cursor pagination

If the decorated field implements cursor-based pagination and provides a `first` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={forwardPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={forwardPaginationStoreAfter} />
</Transformation>

### Backwards cursor pagination

If the decorated field implements cursor-based pagination and provides a `last` argument, the query store will be
generated with an extra method that loads more data and a field pointing to a store with the current `pageInfo`
object. This extra field can be used to track if there are more pages to load:

<Transformation>
	<Highlight slot="from" code={backwardsPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={backwardsPaginationStoreAfter} />
</Transformation>

### Offset/limit Pagination

If the decorated field implements offset/limit pagination and provides a `limit` argument, the query store will be generated with an extra methods that lets it load more pages after the one the current one:

<Transformation>
	<Highlight slot="from" code={offsetPaginationStoreBefore} language={graphql} />
	<HighlightAuto slot="to" code={offsetPaginationStoreAfter} />
</Transformation>

{/if}
