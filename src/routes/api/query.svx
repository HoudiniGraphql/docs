---
title: Query
index: 1
description: Queries in Houdini
---

<script>
    import HeaderWithMode from './_HeaderWithMode.svelte'

     let mode 
</script>

<HeaderWithMode title="Query" bind:mode  />

Load data from the server and subscribe to any changes of fields we detect from mutations, subscriptions, and other queries.

{#if mode === 'inline'}

```svelte
<script>
	import { query, graphql } from '$houdini'
	const { data, refetch, loading, error } = query(graphql`
		query MyQuery {
			myField
		}
	`)
</script>
```

### Inputs

1. A string tagged with `graphql` containing a single document with one named query

### Return Values

`query` returns a single object with the following keys:

- `data` is a store containing the result of the query. It's value will update as mutations, subscriptions, and other queries provide more recent information.
- `refetch` is a function that will refetch the query with a new set of arguments.
- `loading` is a store containing the loading state (`true` or `false`) for a query found outside of a route component (ie, not defined in `src/routes`)
- `error` is a store containing any error values that occur for a query found outside of a route component (ie, not defined in `src/routes`)
- `partial` is a store containing a boolean that indicates if the result has a partial match

## Query Variables

At the moment, query variables are declared as a function in the module context of your component.
This function must be named after your query and in a sapper application, it takes the same arguments
that are passed to the `preload` function described in the [Sapper](https://sapper.svelte.dev/docs#Pages)
documentation. In a SvelteKit project, this function takes the same arguments passed to the `load` function
described in the [SvelteKit](https://kit.svelte.dev/docs#Loading) docs. Regardless of the framework, you can return
the value from `this.error` and `this.redirect` in order to change the behavior of the response. Here is a
modified example [from the source repository](./https://github.com/HoudiniGraphql/houdini/tree/main/example):

```svelte
<script context="module" lang="ts">
	// This is the function for the AllItems query.
	// Query variable functions must be named <QueryName>Variables.
	export function AllItemsVariables(page): AllItems$input {
		// make sure we recognize the value
		if (!['active', 'completed'].includes(page.params.filter)) {
			return this.error(400, 'invalid filter')
		}

		return {
			completed: page.params.filter === 'completed'
		}
	}
</script>

<!-- src/routes/[filter].svelte -->
<script lang="ts">
	import { query, graphql, AllItems } from '$houdini'

	// load the items
	const { data } = query<AllItems>(graphql`
		query AllItems($completed: Boolean) {
			items(completed: $completed) {
				id
				text
			}
		}
	`)
</script>

{#each $data.items as item}
	<div>{item.text}</div>
{/each}
```

## Paginated Queries

Paginated queries must use the `paginatedQuery` function exported from your runtime and contain the `@paginate` directive on the appropriate field. For more information Houdini's support for pagination, please visit the [Pagination guide](/guides/pagination).

```svelte
<script>
	import { paginatedQuery, graphql } from '$houdini'
	const { data, loadNextPage } = paginatedQuery(graphql`
		query UserList {
			friends(last: 10) @paginate {
				edges {
					node {
						id
					}
				}
			}
		}
	`)
</script>
```

### Return Values

`paginatedQuery` returns the same values as `query` with a few additions:

- `loadNextPage` is an async function that loads the next page. It takes one optional argument: the page size to load for the next request.
- `loadPreviousPage` is an async function that loads the previous page. It takes one optional argument: the page size to load for the next request.
- `loading` is a store containing a boolean value that tracks the loading state of the pagination requests
- `pageInfo` is a store that contains the page info (`hasPreviousPage`, `hasNextPage`, etc.) Only valid for cursor-based pagination.
- `partial` is a store containing a boolean that indicates if the result has a partial match

## Loading State

The methods used for tracking the loading state of your queries changes depending
on the context of your component. For queries that live in routes (ie, in
`/src/routes/...`), the actual query happens in a `load` which means the best way to track
if your query is loading is to use the
[navigating store](https://kit.svelte.dev/docs#modules-$app-stores) exported from `$app/stores`:

```svelte
<!-- src/routes/index.svelte -->
<script>
    import { query } from '$houdini'
    import { navigating } from '$app/stores'

    const { data } = query(...)
</script>

{#if $navigating}
	loading...
{:else}
	data is loaded!
{/if}
```

However, since queries inside of non-route components (ie, ones that are not defined in `/src/routes/...`)
do not get hoisted to a `load` function, the recommended practice to is use the store returned from
the result of query:

```svelte
<!-- src/components/MyComponent.svelte -->
<script>
    import { query } from '$houdini'

    const { data, loading } = query(...)
</script>

{#if $loading}
	loading...
{:else}
	data is loaded!
{/if}
```

## Refetching Data

Refetching data is done with the `refetch` function provided from the result of a query:

```svelte
<script lang="ts">
	import { query, graphql, AllItems } from '$houdini'

	// load the items
	const { refetch } = query<AllItems>(graphql`
		query AllItems($completed: Boolean) {
			items(completed: $completed) {
				id
				text
			}
		}
	`)

	let completed = true

	$: refetch({ completed })
</script>

<input type="checkbox" bind:checked={completed} />
```

{:else}

```svelte
<script context="module">
    import ViewerProfileStore from '$houdini/stores/ViewerProfile'

    export async load(event) {
        // make sure the store has the latest data
        await ViewerProfileStore.fetch({ event })

        // have to return _something_ to make SvelteKit happy
        return {}
    }
</script>

{$ViewerProfileStore.data.viewerProfile.firstName}
```

## Methods and Fields

### Fetch

```

```

{/if}
