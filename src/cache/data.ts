export const docs = [{"href":"authentication#authentication","title":"üîê¬†¬†Authentication","content":"houdini defers to SvelteKit's sessions for authentication. Assuming that the session has been populated\nsomehow, you can access it through the second argument in the environment definition://src/environment.ts\n\nimport { Environment } from '$houdini';\n\n// this function can take a second argument that will contain the session\n// data during a request or mutation\nexport default new Environment(async function (\n\t{ text, variables = {} },\n\tsession\n) {\n\tconst result = await this.fetch('http://localhost:4000', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: session.token ? `Bearer ${session.token}` : null,\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tquery: text,\n\t\t\tvariables,\n\t\t}),\n\t});\n\n\t// parse the result as json\n\treturn await result.json();\n});"},{"href":"contributing#contributing","title":"Contributing","content":"If you are interested in helping out, you can find our GitHub page and the contributing guide should provide some guidance. If you need something more specific, feel free to reach out to @AlecAivazis on the Svelte discord. There's lots to do regardless of how deep you want to dive üôÇ"},{"href":"custom-scalars#Ô∏ècustom-scalars","title":"‚öñÔ∏è¬†Custom Scalars","content":"Configuring your runtime to handle custom scalars is done under the scalars key in your config:// houdini.config.js\n\nexport default {\n\t// ...\n\n\tscalars: {\n\t\t// the name of the scalar we are configuring\n\t\tDateTime: {\n\t\t\t// the corresponding typescript type\n\t\t\ttype: 'Date',\n\t\t\t// turn the api's response into that type\n\t\t\tunmarshal(val) {\n\t\t\t\treturn new Date(val);\n\t\t\t},\n\t\t\t// turn the value into something the API can use\n\t\t\tmarshal(date) {\n\t\t\t\treturn date.getTime();\n\t\t\t},\n\t\t},\n\t},\n};"},{"href":"fragments#fragments","title":"üß©¬†¬†Fragments","content":"Your components will want to make assumptions about which attributes are\navailable in your queries. To support this, Houdini uses GraphQL fragments embedded\nwithin your component. Take, for example, a UserAvatar component that requires\nthe profilePicture field of a User:// components/UserAvatar.svelte\n\n<script lang=\"ts\">\n    import { fragment, graphql, UserAvatar } from '$houdini'\n\n    // the reference will get passed as a prop\n    export let user: UserAvatar\n\n    const data = fragment(graphql`\n        fragment UserAvatar on User {\n            profilePicture\n        }\n    `, user)\n</script>\n\n<img src={$data.profilePicture} />This component can be rendered anywhere we want to query for a user, with a guarantee\nthat all necessary data has been asked for:// src/routes/users.svelte\n\n<script>\n    import { query, graphql, AllUsers } from '$houdini'\n    import { UserAvatar } from 'components'\n\n    const { data } = query<AllUsers>(graphql`\n        query AllUsers {\n            users {\n                id\n                ...UserAvatar\n            }\n        }\n    `)\n</script>\n\n{#each $data.users as user}\n    <UserAvatar user={user} />\n{/each}It's worth mentioning explicitly that a component can rely on multiple fragments\nat the same time so long as the fragment names are unique and prop names are different."},{"href":"fragments#fragment-arguments","title":"Fragment Arguments","content":"In some situations it's necessary to configure the documents inside of a fragment. For example,\nyou might want to extend the UserAvatar component to allow for different sized profile pictures.\nTo support this, houdini provides two directives @arguments and @with which declare arguments\nfor a fragment and provide values, respectively.Default values can be provided to fragment arguments with the default key:fragment UserAvatar on User @arguments(width: { type: \"Int\", default: 50 }) {\n\tprofilePicture(width: $width)\n}In order to mark an argument as required, pass the type with a ! at the end.\nIf no value is provided, an error will be thrown when generating your runtime.fragment UserAvatar on User @arguments(width: { type: \"Int!\" }) {\n\tprofilePicture(width: $width)\n}Providing values for fragments is done with the @with decorator:query AllUsers {\n\tusers {\n\t\t...UserAvatar @with(width: 100)\n\t}\n}Keep in mind, if you are using fragment variables inside of a field flagged for\nlist operations, you'll have to pass a value for the variable when performing the operation"},{"href":"getting-started#installation","title":"Installation","content":"houdini is available on npm.yarn add -D houdini houdini-preprocess\n# or\nnpm install --save-dev houdini houdini-preprocess"},{"href":"getting-started#configuring-your-application","title":"Configuring Your Application","content":"Adding houdini to an existing project can easily be done with the provided command-line tool. If you don't already have an existing app, visit this link for help setting one up. Once you have a project and want to add houdini, execute the following command which will create a few necessary files, as well as pull down a json representation of your API's schema.npx houdini initThis will send a request to your API to download your schema definition.If you need\nheaders to authenticate this request, you can pass them in with the --pull-header\nflag (abbreviated -ph). For example,npx houdini init -ph Authorization=\"Bearer MyToken\"You will also need to provide the same flag to generate when using the\n--pull-schema flag.Finally, follow the steps appropriate for your framework."},{"href":"getting-started#sveltekit","title":"SvelteKit","content":"We need to define an alias so that your codebase can import the generated runtime. Add the following values to svelte.config.js:import houdini from 'houdini-preprocess'\n\n{\n    preprocess: [houdini()],\n\n    kit: {\n        vite: {\n            resolve: {\n                alias: {\n                    $houdini: path.resolve('.', '$houdini')\n                }\n            }\n        }\n    }\n}And finally, we need to configure our application to use the generated network layer. To do this, add the following block of code to src/routes/__layout.svelte:<script context='module'>\n\timport env from '../environment'; import {setEnvironment} from '$houdini';\n\tsetEnvironment(env);\n</script>You might need to generate your runtime in order to fix typescript errors.Note: If you are building your application with\nadapter-static (or any other adapter that turns\nyour application into a static site), you will need to set the static value in your config file to true."},{"href":"getting-started#sapper","title":"Sapper","content":"You'll need to add the preprocessor to both your client and your server configuration:import houdini from 'houdini-preprocess';\n\n// add to both server and client configurations\n{\n\tplugins: [\n\t\tsvelte({\n\t\t\tpreprocess: [houdini()],\n\t\t}),\n\t];\n}With that in place, the only thing left to configure your Sapper application is to connect your client and server to the generate network layer:// in both src/client.js and src/server.js\n\nimport { setEnvironment } from '$houdini';\nimport env from './environment';\n\nsetEnvironment(env);"},{"href":"getting-started#svelte","title":"Svelte","content":"If you are working on an application that isn't using SvelteKit or Sapper, you have to configure the\ncompiler and preprocessor to generate the correct logic by setting the framework field in your\nconfig file to \"svelte\".Please keep in mind that returning the response from a query, you should not rely on this.redirect to handle the\nredirect as it will update your browsers location attribute, causing a hard transition to that url. Instead, you should\nuse this.error to return an error and handle the redirect in a way that's appropriate for your application."},{"href":"getting-started#running-the-compiler","title":"Running the Compiler","content":"The compiler is responsible for a number of things, ranging from generating the actual runtime\nto creating types for your documents. Running the compiler can be done with npx or via a script\nin package.json and needs to be run every time a GraphQL document in your source code changes:npx houdini generateThe generated runtime can be accessed by importing $houdini anywhere in your application.If you have updated your schema on the server, you can pull down the most recent schema before generating your runtime by using --pull-schema or -p:npx houdini generate --pull-schema"},{"href":"getting-started#config-file","title":"üìÑ¬†Config File","content":"All configuration for your houdini application is defined in a single file that is imported by both the runtime and the\ncommand-line tool. Because of this, you must make sure that any imports and logic are resolvable in both environments.\nThis means that if you rely on process.env or other node-specifics you will have to use a\nplugin to replace the expression with something that can run in the browser."},{"href":"index#houdini","title":"Houdini","content":"The disappearing GraphQL client for Sapper and SvelteKit.Composable and colocated data requirements for your componentsNormalized cache with declarative updatesGenerated typesSubscriptionsSupport for SvelteKit and SapperPagination (cursors and offsets)At its core, houdini seeks to enable a high quality developer experience without compromising bundle size. Like Svelte, houdini shifts what is traditionally handled by a bloated runtime into a compile step that allows for the generation of an incredibly lean GraphQL abstraction for your application."},{"href":"index#example","title":"Example","content":"A demo can be found in the example directory.Please note that the examples in that directory and this readme showcase the typescript definitions generated by the compiler. While it is highly recommended, Typescript is NOT required in order to use houdini."},{"href":"mutations#mutations","title":"üìù¬†¬†Mutations","content":"Mutations are defined in your component like the rest of the documents but\ninstead of triggering a network request when called, you get a function\nwhich can be invoked to execute the mutation. Here's another modified example from\nthe demo:<script lang=\"ts\">\n    import { mutation, graphql, UncheckItem } from '$houdini'\n\n    let itemID: string\n\n    const uncheckItem = mutation<UncheckItem>(graphql`\n        mutation UncheckItem($id: ID!) {\n            uncheckItem(item: $id) {\n                item {\n                    id\n                    completed\n                }\n            }\n        }\n    `)\n</script>\n\n<button on:click={() => uncheckItem({ id: itemID })}>\n    Uncheck Item\n</button>Note: mutations usually do best when combined with at least one fragment grabbing\nthe information needed for the mutation (for an example of this pattern, see below.)"},{"href":"mutations#updating-fields","title":"Updating fields","content":"When a mutation is responsible for updating fields of entities, houdini\nshould take care of the details for you as long as you request the updated data alongside the\nrecord's id. Take for example, an TodoItemRow component:<script lang=\"ts\">\n    import { fragment, mutation, graphql, TodoItemRow } from '$houdini'\n\n    export let item: TodoItemRow\n\n    // the resulting store will stay up to date whenever `checkItem`\n    // is triggered\n    const data = fragment(\n        graphql`\n            fragment TodoItemRow on TodoItem {\n                id\n                text\n                completed\n            }\n        `,\n        item\n    )\n\n    const checkItem = mutation<CompleteItem>(graphql`\n        mutation CompleteItem($id: ID!) {\n            checkItem(item: $id) {\n                item {\n                    id\n                    completed\n                }\n            }\n        }\n    `)\n</script>\n\n<li class:completed={$data.completed}>\n    <input\n        name={$data.text}\n        class=\"toggle\"\n        type=\"checkbox\"\n        checked={$data.completed}\n        on:click={handleClick}\n    />\n    <label for={$data.text}>{$data.text}</label>\n    <button class=\"destroy\" on:click={() => deleteItem({ id: $data.id })} />\n</li>"},{"href":"mutations#lists","title":"Lists","content":"Adding and removing records from a list is done by mixing together a few different generated fragments\nand directives. In order to tell the compiler which lists are targets for these operations, you have to\nmark them with the @list directive and provide a unique name:query AllItems {\n\titems @list(name: \"All_Items\") {\n\t\tid\n\t}\n}It's recommended to name these lists with a different casing convention than the rest of your\napplication to distinguish the generated fragments from those in your codebase."},{"href":"mutations#inserting-a-record","title":"Inserting a record","content":"With this field tagged, any mutation that returns an Item can be used to insert items in this list:mutation NewItem($input: AddItemInput!) {\n\taddItem(input: $input) {\n\t\t...All_Items_insert\n\t}\n}"},{"href":"mutations#removing-a-record","title":"Removing a record","content":"Any mutation that returns an Item can also be used to remove an item from the list:mutation RemoveItem($input: RemoveItemInput!) {\n\tremoveItem(input: $input) {\n\t\t...All_Items_remove\n\t}\n}"},{"href":"mutations#deleting-a-record","title":"Deleting a record","content":"Sometimes it can be tedious to remove a record from every single list that mentions it.\nFor these situations, Houdini provides a directive that can be used to mark a field in\nthe mutation response holding the ID of a record to delete from all lists.mutation DeleteItem($id: ID!) {\n\tdeleteItem(id: $id) {\n\t\titemID @Item_delete\n\t}\n}"},{"href":"mutations#conditionals","title":"Conditionals","content":"Sometimes you only want to add or remove a record from a list when an argument has a particular value.\nFor example, in a todo list you might only want to add the result to the list if there is no filter being\napplied. To support this, houdini provides the @when and @when_not directives:mutation NewItem($input: AddItemInput!) {\n\taddItem(input: $input) {\n\t\t...All_Items_insert @when_not(completed: true)\n\t}\n}"},{"href":"notes-constraints-conventions#Ô∏ènotes-constraints-and-conventions","title":"‚ö†Ô∏è¬†¬†Notes, Constraints, and Conventions","content":"The compiler must be run every time the contents of a graphql tagged string changesEvery GraphQL Document must have a name that is uniqueVariable functions must be named after their queryDocuments with a query must have only one operation in themDocuments without an operation must have only one fragment in them"},{"href":"pagination#Ô∏èpagination","title":"‚ôªÔ∏è¬†Pagination","content":"Pagination in Houdini follows the connection.It's often the case that you want to avoid querying an entire list from your API in order\nto minimize the amount of data transfers over the network. To support this, GraphQL APIs will\n\"paginate\" a field, allowing users to query a slice of the list. The strategy used to access\nslices of a list fall into two categories. Offset-based pagination relies offset and limit\narguments and mimics the mechanisms provided by most database engines. Cursor-based pagination\nis a bi-directional strategy that relies on first/after or last/before arguments and\nis designed to handle modern pagination features such a infinite scrolling.Regardless of the strategy used, houdini follows a simple pattern: wrap your document in a\n\"paginated\" function (ie, paginatedQuery or paginatedFragment), mark the field with\n@paginate, and provide the \"page size\" via the first, last or limit arguments to the field.\npaginatedQuery and paginatedFragment behave identically: they return a data field containing\na svelte store with your full dataset, functions you can call to load the next or previous\npage, as well as a readable store with a boolean loading state. For example, a field\nsupporting offset-based pagination would look something like:const { data, loadNextPage, loading } = paginatedQuery(graphql`\n\tquery UserList {\n\t\tfriends(limit: 10) @paginate {\n\t\t\tid\n\t\t}\n\t}\n`);and a field that supports cursor-based pagination starting at the end of the list would look something like:const { data, loadPreviousPage } = paginatedQuery(graphql`\n\tquery UserList {\n\t\tfriends(last: 10) @paginate {\n\t\t\tedges {\n\t\t\t\tnode {\n\t\t\t\t\tid\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n`);If you are paginating a field with a cursor-based strategy (forward or backwards), the current page\ninfo can be looked up with the pageInfo store returned from the paginated function:<script>\n    const { data, loadNextPage, pageInfo } = paginatedQuery(graphql`\n        query UserList {\n            friends(first: 10) @paginate {\n                edges {\n                    node {\n                        id\n                    }\n                }\n            }\n        }\n    `)\n</script>\n\n{#if $pageInfo.hasNextPage}\n    <button onClick={() => loadNextPage()}> load more </button>\n{/if}"},{"href":"pagination#paginated-fragments","title":"Paginated Fragments","content":"paginatedFragment functions very similarly to paginatedQuery with a few caveats.\nConsider the following:const { loadNextPage, data, pageInfo } = paginatedFragment(graphql`\n\tfragment UserWithFriends on User {\n\t\tfriends(first: 10) @paginate {\n\t\t\tedges {\n\t\t\t\tnode {\n\t\t\t\t\tid\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n`);In order to look up the next page for the user's friend. We need a way to query the specific user\nthat this fragment has been spread into. In order to pull this off, houdini relies on the generic Node\ninterface and corresponding query:interface Node {\n\tid: ID!\n}\n\ntype Query {\n\tnode(id: ID!): Node\n}In short, this means that any paginated fragment must be of a type that implements the Node interface\n(so it can be looked up in the api). You can read more information about the Node interface in\nthis section of the graphql community website.\nThis is only a requirement for paginated fragments. If your application only uses paginated queries,\nyou do not need to implement the Node interface and resolver."},{"href":"pagination#mutation-operations","title":"Mutation Operations","content":"A paginated field can be marked as a potential target for a mutation operation by passing\na name argument to the @paginate directive:const { loadNextPage, data, pageInfo } = paginatedFragment(graphql`\n\tfragment UserWithFriends on User {\n\t\tfriends(first: 10) @paginate(name: \"User_Friends\") {\n\t\t\tedges {\n\t\t\t\tnode {\n\t\t\t\t\tid\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n`);"},{"href":"persisted-queries#persisted-queries","title":"üö¶¬†¬†Persisted Queries","content":"Sometimes you want to confine an API to only fire a set of pre-defined queries. This\ncan be useful to not only reduce the amount of information transferred over the write\nbut also act as a list of approved queries, providing additional security. Regardless of\nyour motivation, the approach involves associating a known string with a particular query\nand sending that string to the server instead of the full query body. To support this,\nhoudini passes a queries hash to the fetch function for you to use."},{"href":"persisted-queries#automatic-persisted-queries","title":"Automatic Persisted Queries","content":"An approach to Persisted Queries, popularized by Apollo, is known as\nAutomatic Persisted Queries.\nThis involves first sending a queries hash and if its unrecognized, sending the full\nquery string. This might look something like:/// src/environment.ts\n\n// This sends the actual fetch request to the server\nasync function sendFetch({ text, variables, hash }) {\n\tconst result = await this.fetch('localhost:4000/graphql', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tquery: text ? text : undefined,\n\t\t\tvariables,\n\t\t\textensions: {\n\t\t\t\tpersistedQuery: {\n\t\t\t\t\tversion: 1,\n\t\t\t\t\tsha256Hash: hash,\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\treturn result.json();\n}\n\nexport default new Environment(async function ({ text, variables = {}, hash }) {\n\t// first send the request without the text, only the hash\n\tconst response = await sendFetch.call(this, { variables, hash, text: null });\n\n\t// if there were no errors, we're good to go\n\tif (!response.errors) {\n\t\treturn response;\n\t}\n\n\t// there were errors, send the hash and the query to associate the two for\n\t// future requests\n\treturn await sendFetch.call(this, { variables, hash, text });\n});"},{"href":"persisted-queries#fixed-list-of-persisted-queries","title":"Fixed List of Persisted Queries","content":"If you don't want the flexibility of Automatic Persisted Queries, you will need\na fixed association of hash to query for every document that your client will send.\nTo support this, you can pass the --persist-output flag to the generate command\nand provide a path to save the map:npx houdini generate --persist-output ./path/to/persisted-queries.json\n# or\nnpx houdini generate -po ./path/to/persisted-queries.jsonOnce this map has been created, you will have to make it available to your server.Now, instead of sending the full operation text with every request, you can now simply\npass the hash under whatever field name you prefer:/// src/environment.ts\n\nexport default new Environment(async function ({ text, variables = {}, hash }) {\n\tconst result = await this.fetch('http://localhost:4000', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\tdoc_id: hash,\n\t\t\tvariables,\n\t\t}),\n\t});\n\n\t// parse the result as json\n\treturn await result.json();\n});"},{"href":"queries#queries","title":"Queries","content":"Grabbing data from your API is done with the query function:<script lang=\"ts\">\n    import { query, graphql, AllItems } from '$houdini'\n\n    // load the items\n    const { data } = query<AllItems>(graphql`\n        query AllItems {\n            items {\n                id\n                text\n            }\n        }\n    `)\n</script>\n\n{#each $data.items as item}\n    <div>{item.text}</div>\n{/each}The workflow for making a new query is the followingWrite the query, that is const { data } = query(graphql...Run the compiler, that is npx houdini generate, or if the query is new from the backend, run npx houdini generate --pull-schema to pull down the most recent schemaUse the newly generated type, that is const { data } = query<AllItems>(..."},{"href":"queries#query-variables-and-page-data","title":"Query variables and page data","content":"At the moment, query variables are declared as a function in the module context of your component.\nThis function must be named after your query. In a SvelteKit project, this function takes the same arguments passed to the load function\ndescribed in the SvelteKit docs while in a sapper application, it takes the same arguments\nthat are passed to the preload function described in the Sapper\ndocumentation. Regardless of the framework, you can return\nthe value from this.error and this.redirect in order to change the behavior of the response. Here is a\nmodified example from the demo:// src/routes/[filter].svelte\n\n<script lang=\"ts\">\n    import { query, graphql, AllItems } from '$houdini'\n\n    // load the items\n    const { data } = query<AllItems>(graphql`\n        query AllItems($completed: Boolean) {\n            items(completed: $completed) {\n                id\n                text\n            }\n        }\n    `)\n</script>\n\n<script context=\"module\" lang=\"ts\">\n    // This is the function for the AllItems query.\n    // Query variable functions must be named <QueryName>Variables.\n    export function AllItemsVariables(page): AllItems$input {\n        // make sure we recognize the value\n        if (!['active', 'completed'].includes(page.params.filter)) {\n            return this.error(400, \"filter must be one of 'active' or 'completed'\")\n        }\n\n        return {\n            completed: page.params.filter === 'completed',\n        }\n    }\n</script>\n\n{#each $data.items as item}\n    <div>{item.text}</div>\n{/each}"},{"href":"queries#loading-state","title":"Loading State","content":"The methods used for tracking the loading state of your queries changes depending\non the context of your component. For queries that live in routes (ie, in\n/src/routes/...), the actual query happens in a load function as described\nin What about load?Because of this, the best way to track\nif your query is loading is to use the\nnavigating store exported from $app/stores:// src/routes/index.svelte\n\n<script>\n    import { query } from '$houdini'\n    import { navigating } from '$app/stores'\n\n    const { data } = query(...)\n</script>\n\n{#if $navigating}\n    loading...\n{:else}\n    data is loaded!\n{/if}However, since queries inside of non-route components (ie, ones that are not defined in /src/routes/...)\ndo not get hoisted to a load function, the recommended practice to is use the store returned from\nthe result of query:// src/components/MyComponent.svelte\n\n<script>\n    import { query } from '$houdini'\n\n    const { data, loading } = query(...)\n</script>\n\n{#if $loading}\n    loading...\n{:else}\n    data is loaded!\n{/if}"},{"href":"queries#additional-logic","title":"Additional logic","content":"Sometimes you will need to add additional logic to a component's query. For example, you might want to\ncheck if the current session is valid before a query is sent to the server. In order to support this,\nhoudini will look for a function called onLoad defined in the module context which can be used to perform\nany logic you need. If you return a value from this function, it will be passed as props to your component:<script context=\"module\">\n    // It has access to the same arguments and this.error this.redirect as the variable functions\n    export function onLoad({page, session}){\n        if(!session.authenticated){\n            return this.redirect(302, '/login')\n        }\n\n\treturn {\n\t    message: \"There are this many items\"\n        }\n    }\n</script>\n\n<script>\n    import { query, graphql } from '$houdini'\n\n    export let message\n\n    // load the items\n    const { data } = query(graphql`\n        query AllItems {\n            items {\n                id\n            }\n        }\n    `)\n</script>\n\n{message}: {$data.items.length}"},{"href":"queries#refetching-data","title":"Refetching Data","content":"Refetching data is done with the refetch function provided from the result of a query:\n<script lang=\"ts\">\n    import { query, graphql, AllItems } from '$houdini'\n\n    // load the items\n    const { refetch } = query<AllItems>(graphql`\n        query AllItems($completed: Boolean) {\n            items(completed: $completed) {\n                id\n                text\n            }\n        }\n    `)\n\n    let completed = true\n\n    $: refetch({ completed })\n</script>\n\n<input type=checkbox bind:checked={completed}>"},{"href":"queries#cache-policy","title":"Cache policy","content":"By default, houdini will only try to load queries against its local cache when you indicate it is safe to do so.\nThis can be done with the @cache directive:query AllItems @cache(policy: CacheOrNetwork) {\n\titems {\n\t\tid\n\t\ttext\n\t}\n}There are 3 different policies that can be specified:CacheOrNetwork will first check if a query can be resolved from the cache. If it can, it will return the cached value and only send a network request if data was missing.CacheAndNetwork will use cached data if it exists and always send a network request after the component has mounted to retrieve the latest data from the serverNetworkOnly will never check if the data exists in the cache and always send a network request"},{"href":"queries#data-retention","title":"Data Retention","content":"Houdini will retain a query's data for a configurable number of queries (default 10).\nFor a concrete example, consider an example app that has 3 routes. If you load one of the\nroutes and then click between the other two 5 times, the first route's data will still be\nresolvable (and the counter will reset if you visit it).\nIf you then toggle between the other routes 10 times and then try to load the first\nroute, a network request will be sent. This number is configurable with the\ncacheBufferSize value in your config file:// houdini.config.js\n\nexport default {\n\t// ...\n\tcacheBufferSize: 5,\n};"},{"href":"queries#changing-default-cache-policy","title":"Changing default cache policy","content":"As previously mentioned, the default cache policy is CacheOrNetwork. This can be changed\nby setting the defaultCachePolicy config value:// houdini.config.js\n\nimport { CachePolicy } from '$houdini';\n\nexport default {\n\t// ...\n\n\t// note: if you are upgrading from a previous version of houdini, you might\n\t// have to generate your runtime for this type to be defined.\n\tdefaultCachePolicy: CachePolicy.NetworkOnly,\n};"},{"href":"queries#what-about-load","title":"What about load?","content":"Don't worry - that's where the preprocessor comes in. One of its responsibilities is moving the actual\nfetch into a load. You can think of the block at the top of this section as equivalent to:<script context=\"module\">\n    export async function load() {\n            return {\n                _data: await this.fetch({\n                    text: `\n                        query AllItems {\n                            items {\n                                id\n                                text\n                            }\n                        }\n                    `\n                }),\n            }\n    }\n</script>\n\n<script>\n    export let _data\n\n    const data = readable(_data, ...)\n</script>\n\n{#each $data.items as item}\n    <div>{item.text}</div>\n{/each}"},{"href":"subscriptions#subscriptions","title":"üßæ¬†¬†Subscriptions","content":"Subscriptions in houdini are handled with the subscription function exported by your runtime. This function\ntakes a tagged document, and returns a store with the most recent value returned by the server. Keep in mind\nthat houdini will keep the cache (and any subscribing components) up to date as new data is encountered.It's worth mentioning that you can use the same fragments described in the mutation section\nin order to update houdini's cache with the response from a subscription.Here is an example of a simple subscription from the example application included in this repo:<script lang=\"ts\">\n    import {\n        fragment,\n        mutation,\n        graphql,\n        subscription,\n        ItemEntry_item,\n    } from '$houdini'\n\n    // the reference we're passed from our parents\n    export let item: ItemEntry_item\n\n    // get the information we need about the item\n    const data = fragment(/* ... */)\n\n    // since we're just using subscriptions to stay up to date, we don't care about the return value\n    subscription(\n        graphql`\n            subscription ItemUpdate($id: ID!) {\n                itemUpdate(id: $id) {\n                    item {\n                        id\n                        completed\n                        text\n                    }\n                }\n            }\n        `,\n        {\n            id: $data.id,\n        }\n    )\n</script>\n\n<li class:completed={$data.completed}>\n    <div class=\"view\">\n        <input\n            name={$data.text}\n            class=\"toggle\"\n            type=\"checkbox\"\n            checked={$data.completed}\n            on:click={handleClick}\n        />\n        <label for={$data.text}>{$data.text}</label>\n        <button class=\"destroy\" on:click={() => deleteItem({ id: $data.id })} />\n    </div>\n</li>"},{"href":"subscriptions#configuring-the-websocket-client","title":"Configuring the WebSocket client","content":"Houdini can work with any websocket client as long as you can provide an object that satisfies\nthe SubscriptionHandler interface as the second argument to the Environment's constructor. Keep in mind\nthat WebSocket connections only exist between the browser and your API, therefor you must remember to\npass null when configuring your environment on the rendering server."},{"href":"subscriptions#using-graphql-ws","title":"Using graphql-ws","content":"If your API supports the graphql-ws protocol, you can create a\nclient and pass it directly:// environment.ts\n\nimport { createClient } from 'graphql-ws';\nimport { browser } from '$app/env';\n\n// in sapper, this would be something like `(process as any).browser`\nlet socketClient = browser\n\t? new createClient({\n\t\t\turl: 'ws://api.url',\n\t  })\n\t: null;\n\nexport default new Environment(fetchQuery, socketClient);"},{"href":"subscriptions#using-subscriptions-transport-ws","title":"Using subscriptions-transport-ws","content":"If you are using the deprecated subscriptions-transport-ws library and associated protocol,\nyou will have to slightly modify the above block:// environment.ts\n\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\nimport { browser } from '$app/env';\n\nlet socketClient: SubscriptionHandler | null = null;\nif (browser) {\n\t// instantiate the transport client\n\tconst client = new SubscriptionClient('ws://api.url', {\n\t\treconnect: true,\n\t});\n\n\t// wrap the client in something houdini can use\n\tsocketClient = {\n\t\tsubscribe(payload, handlers) {\n\t\t\t// send the request\n\t\t\tconst { unsubscribe } = client.request(payload).subscribe(handlers);\n\n\t\t\t// return the function to unsubscribe\n\t\t\treturn unsubscribe;\n\t\t},\n\t};\n}\n\nexport default new Environment(fetchQuery, socketClient);"}]