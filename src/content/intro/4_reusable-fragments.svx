---
title: Reusable Fragments
---

<script>
    import { Highlight } from 'svelte-highlight'
    import  Icon  from '~/components/Icon.svelte'
    import graphqlLangDef from '~/lib/graphql-language'

    const graphql = { name: 'graphql', register: graphqlLangDef }
</script>

# Reusable Fragments

As you've seen, we can get pretty far by just using GraphQL queries to define our route's data requirements. However, as our application grows this practice does not scale very well. To illustrate this point, look at how we used the `Sprite` component earlier (copied below without the unrelated bits):

```svelte
<script>
    const { data } = query(graphql`
        query SpeciesInfo($id: Int!) {
            species(id: $id) {
                name
                sprites {
                    front
                }
            }
        }
    `)
</script>

<Sprite
    id="species-sprite"
    src={$data.species.sprites.front}
    speciesName={$data.species.name}
/>

```

At first it might not be clear what the problem is. `Sprite` defines some props so we had to look up the necessary information in order to give those props their value. However, for the sake of argument, imagine that `Sprite` is used in many different views across our application. Every place where it shows up, we will have to remember to ask for these two pieces of data so that we can provide the props with the correct value. On top of that, as `Sprite` evolves to do more, we will have to make sure that everywhere we use it also asks for the new data. Our route is now tightly coupled to `Sprite`'s implementation.

Wouldn't it be nice if we had some way of defining these requirements inside of `Sprite` so we didn't have to worry about the exact details and could ensure that the query included whatever information `Sprite` needs? Well, that's where GraphQL fragments come to the rescue.

## What are Fragments?

It's safe to skip this section if you familiar with GraphQL Fragments.

Fragments are a super powerful tool in GraphQL that is commonly overlooked. In short, they allow us to describe a selection of fields of a given type without having a concrete instance of that type. They look like this:

```graphql
fragment MyFragment on Species {
	name
	flavor_text
}
```

This fragment acts as a reusable bit of query so anywhere we have a field in our document that returns a `Species` we can ask for this data by appending `...` to the fragment name in a selection:

<div style="display: flex; flex-direction: row; align-items: center; overflow-x: auto;">
    <Highlight language={graphql} code={`
query {
    species(id: 1) {
        ...MyFragment
    }
}`} 
    />
        <p style="margin-left: 10px; margin-right: 10px">
            <Icon name="arrow-right" height="30px" width="30px"/>
        </p>
        <Highlight language={graphql} code={`
query {
    species(id: 1) {
        name
        flavor_text 
    }
}`} />
</div>

## Using Fragments

Defining a fragment inside of your component looks a lot like the query from before. Let's see this in action by updating the `Sprite` component to look like this:

```svelte
<!-- src/components/Sprite.svelte -->

<script>
	import { fragment, graphql } from '$houdini'

	export let species

	const data = fragment(graphql`
		fragment SpriteInfo on Species {
			name
			sprites {
				front
			}
		}
	`, species)

</script>

<div id={$$props.id} class="sprite">
	<img
		height="100%"
		src={$data.sprites.front}
		alt={`${$data.name} sprite`}
	/>
</div>
```

Next we have to go back to the route and put this fragment to use. Update the query inside of `src/routes/[...id].svelte` to look like:

```graphql
query SpeciesInfo($id: Int!) {
	species(id: $id) {
		name
		flavor_text
		...SpriteInfo
	}
}
```

And change the instance of `Sprite` to look like:

```svelte
<Sprite
    id="species-sprite"
    species={$data.species}
/>
```

Once that's all done, you will need to regenerate your runtime with `npm run generate` and if everything went according to plan, there shouldn't be any noticeable change in your browser.

## What Just Happened?

That was pretty quick so let's review what we just did:

1. We defined a new fragment in the `Sprite` component which ensured that its parent component always delivered the two pieces of information it needs: the front image source and the name of the species.

1. Instead of asking for those bits of data directly as two individual props, the component now has a single prop, `species`, which we pass to the `fragment` function we imported from houdini in order to get the data we need. Notice we don't use this prop for anything in our component except to pass it into houdini, this ensures we are only using data we asked for in our fragment.

1. We then updated the route's query to use the fragment we defined in the component and passed the `$data.species` reference we got from the query into our `Sprite` component as the new prop.

Notice how our route is no longer tightly coupled to any of `Sprite`'s implementation? All that the route knows is that `Sprite` needs a `Species`, so it just had to connect the dots and let `Sprite` take care of the rest.

Houdini enables us to use fragments as a way to colocate our component's data requirements next to the actual logic that relies on the fields. This not only saves us the extra typing every time we render a `Sprite` but it also lets us grow this component without worrying about updating every instance of it.

## Composing Fragments

It's worth mentioning explicitly that you are free to mix and match fragments how ever you want. Fragments can have fragments inside of them and the same fragment can show up multiple times in a single component. To illustrate this, let's add a section in our Pok√©dex that shows the different evolved forms of the species we're looking at. First, update the route's query to look like this:

```graphql
query SpeciesInfo($id: Int!) {
	species(id: $id) {
		name
		flavor_text
		evolution_chain {
			...SpriteInfo
		}
		...SpriteInfo
	}
}
```

Next, copy and paste the following code above the `nav` in the right panel:

```svelte
INCOMING
```

And finally, regenerate the runtime by executing `npm run generate` in a separate terminal. You should now be able to see the specie's full evolution chain.
